gc - как устроен
scheduler - как устроен - https://www.youtube.com/watch?v=kedW1xO3Zbo&t=2812s
runtime - как устроен
graceful shutdown
го компилятор

goroutines channel wg mutex - параллелизм
интерфейсы - как работают как устроены зачем нужны
контексты - как устроены как работать

map - как устроены старые и новые
slice - как устроены
стринги - как устроены как работать

битовые операции - прочитать ту статью на хабре


func main() {
    a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    s := a[2:5] // s = {3,4,5} len=3 cap=8                        
    s2 := s[5:7] // базовый массив у s - а,  s2 = {8,9} len=2 cap=3

    s2 = append(s2, 11) // s2 = {8,9,11} len=3 cap=3
    s2 = append(s2, 12) // s2 = {8,9,11,12} len=4 cap=6 тут то поменялся базовый массив из-за аппенда


    fmt.Println(a) // a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11} len=10 cap=10
}

/*
Есть шардированное хранилище товаров, шардирование происходит по ID товара
В аргументах запуска шарды указан фильтр и лимит
Фильтр - возрастающая последовательность [start,end] (включительно) ID товаров которые храняться в шарде, они не пересекаются
Лимит - количество товаров, хранящихся в шарде

К примеру в хранилище находится 100_000 товаров, хранилище имеет 6 шард
1 : [1,20_000], 20_000
2: [20_001,40_000], 20_000
3: [40_001,60_000], 20_000
4: [60_001,80_000], 20_000
5: [80_001,90_000], 10_000
6: [90_001,100_000], 10_000

В своем сервисе мы работаем с ID товаров, нам нужно узнать какой шарде принадлежит товар
В сервисе есть актуальные фильтры и лимиты шард, они хранятся в виде слайса структур

Задача: для заданного id товара определить, в какой шарде он находится.
PS в реальности шард очень много, используйте оптимальное решение // можешь решить но я не приму решение, попрошу быстрее написать
PS что быстрее чем 0(n)? 
*/

package main

import "fmt"

type Shard struct {
    name string
    start int
    end int
    limit int
}

//короче реал бин серч видимо )0))0)
func selectShard(productId int, shards []Shard) Shard {
    left, right := 0, len(shards) -1
    
    for left<=right {
        mid := (right+left)/2 
        if productId <= shards[mid].end && productId >= shards[mid].start {
            return shards[mid]
        }
        
        if shards[mid].start > productId{
            right = mid-1          
        }
        else {           
            left = mid+1
        }  
    } 
    
    return Shard{} //zeroval короче
    
}

func shardsInfo() []Shard
        return []Shard{
        {"1", 1, 20_000, 20_000},
        {"2", 20_001, 40_000, 20_000},
        {"3", 40_001, 60_000, 20_000},
        {"4", 60_001, 80_000, 20_000},
        {"5", 80_001, 90_000, 10_000},
        {"6", 90_001, 100_000, 10_000},
    }
}

func main() {
    shards := shardsInfo()
    productId := 55_555
    shard := selectShard(productId, shards)
    fmt.Println(Shard.name) //3
}

Паттерн «Адаптер»

Реализовать паттерн проектирования «Адаптер» на любом примере.

Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.

Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой, несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.

---

Пример из этого каталога

- Есть `A`, который умеет обрабатывать строки через интерфейс `AProcessor` с методом `ProcessString(string) string`.
- Есть `B`, который работает с `[]rune` через интерфейс `BRuneProcessor` с методом `ProcessRunes([]rune) []rune`.
- Клиент ожидает `BRuneProcessor`, а у нас есть только `A`. Мы создаём `AtoBAdapter`, который реализует `BRuneProcessor`, внутри конвертирует `[]rune -> string`, вызывает `A.ProcessString`, а затем конвертирует результат обратно `string -> []rune`.

Когда это нужно

- **Интеграция несовместимых API**: старый модуль возвращает `string`, новый — ожидает `[]rune`.
- **Переиспользование готовых компонентов** без переписывания их API.

Плюсы

- **Разделение ответственности**: не меняем исходные `A` и `B`.
- **Инкапсуляция преобразований** в одном месте (адаптере).

Минусы

- **Дополнительный слой**: небольшая накладная стоимость на обёртку и конвертацию.
- **Усложнение архитектуры** при чрезмерном количестве адаптеров.

Что было исправлено относительно исходника

- Неверное использование интерфейсов вида `Aer.poop`, `Ber.piss` — обращались к интерфейсу как к типу-значению. Теперь используются корректные переменные интерфейсных типов (`var aProc AProcessor = a`).
- Переименованы методы и интерфейсы на осмысленные (`ProcessString`, `ProcessRunes`) вместо сленга.
- Адаптер теперь реализует интерфейс потребителя (`BRuneProcessor`) и делегирует вызовы конкретной реализации (`A`).